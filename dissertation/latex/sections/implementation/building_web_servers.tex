\section{Python Web Servers}
\label{sec:impl_web_srvrs}

For the \theResServer system implementation, we require both a \acrfull{mks} and a \acrfull{prs} serving the requirements described in \Cref{subsec:analysis_deployment_mks} and \Cref{subsec:analysis_deployment_prs}. Both servers are to be implemented as web servers, allowing for simple \acrshort{html} \acrshort{gui}s to be built for user interactions. This implementation allows for non-technical users to use the system without having to learn how to use \acrshort{cli} tools.\\
Additionally, since the \acrshort{mks} would have to integrate the \OpenABE library, it would need to be built with the C language or instead integrate with the \PyOpenABE library of bindings. Since building a web server in the C language was deemed to be an overly complex task for the length of time available to the project, and Python already offers web server frameworks (such as \href{http://flask.pocoo.org/}{Flask} \& \href{https://www.djangoproject.com/}{Django}), the project selected Python as the main language for implementation.\\
As a result, the \acrshort{mks} was built with the Python \href{http://flask.pocoo.org/}{Flask microframework} for its lightweight design and minimal feature set. Ultimately, relying on the fact that both web servers would only require very basic \acrshort{html} \acrshort{gui}s, which would not require the bulk of a Django project. Either framework would have provided the seamless integration of \PyOpenABE that was required for the \acrshort{mks}.
\vskip 0.5em
The \acrshort{prs} did not require integration with the \PyOpenABE library of bindings (as described in \Cref{subsec:analysis_deployment_prs}) however did require a connection to a local database for storing metadata of resources. MongoDB was selected for this purpose (as explained in \Cref{sec:impl_mongodb}) and Python offers the official \href{https://api.mongodb.com/python/current/}{PyMongo distribution} for this exact connection functionality.\\
This MongoDB database is an absolute requirement for the \acrshort{prs} since the system stores encrypted resources under unique filenames generated with Python's \acrshort{uuid} package, implementing the \acrfull{uuid} scheme as defined by RFC 4122 \citep{rfc4122}. This ensures that a guaranteed unique filename will be generated for every resource, and by overwriting the user-provided filename we gain protection against malicious attempts to provide invalid or dangerous filenames. We also do not have to handle the scenario of two resources being uploaded with the same filename, as the \acrshort{uuid} becomes the ID for the resource.\\
Since every resource will get a new \acrshort{uuid} filename, such as \textit{``12345678-1234-5678-1234-567812345678''}, the MongoDB database must store the original filename and new filename for each resource, providing a mapping of each resource's filenames. Meaning a user may seamlessly view and search the original filenames, by interfacing with the database but upon retrieving a file the system will return the encrypted resource file through the stored \acrshort{uuid}.\\
Lastly, Python also offers a fuzzy string matcher, the \href{https://pypi.org/project/fuzzywuzzy/}{FuzzyWuzzy} package, to meet the filename searching needs detailed in \Cref{sec:design_file_search}. This package combined with the built-in string matching of MongoDB (detailed in \Cref{sec:impl_mongodb}) provides both methods required for filename searching.
