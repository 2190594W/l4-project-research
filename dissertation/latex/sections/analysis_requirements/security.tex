\section{Security Considerations}
\label{sec:analysis_security}

A Resource Server must be built with security as a top priority, or risk resources being vulnerable to attacks and security breaches. Access to resources \textit{can} be managed with Access Control alone, ensuring that only authorised users may view or download a particular resource. Whilst this can meet the basic security needs for a business, no fallback protection is provided in the event of a security breach. Further, within organisations, the security requirements are even higher with more restrictive access and mandatory at-rest encryption being commonplace.

\subsection{Securing Resources}
\label{subsec:analysis_sec_res}

Although open and public resource repositories do exist, such as the \href{https://commons.wikimedia.org/wiki/Main_Page}{Wikimedia Commons} service, they are the edge case across the Internet. A more common setup is a public service with both public and private resources, such as GitHub where code repositories may be set to `private' if a user wishes their code to be hidden from the general public.\\
Files marked as `private' by a user, must remain private and hidden from the general public because a user has a certain expectation that files they upload to a service as `private', cannot be discovered \textbf{or} accessed by other users \textemdash\ unless explicit access has been granted. This expectation must be met by the service or the user's trust is at risk and with it, any future use of the service.
\vskip 0.5em
Access Control is often implemented as the sole method of protecting a user's resources from unauthorised access. This is enough protection for many services, as a user must authenticate to gain access to different routes and locations of a website, with their account dictating if access should be granted or denied. The implications and intricacies of such an authentication system are not within the scope of this project, however the following may provide further information \textemdash\ \citet{Sandhu1996, Johnston2004, Fu2001}.\\
Employment of Access Control as the main defence against unauthorised access works perfectly, until we consider the possibility of a system breach occurring. In such a scenario, the attacker may have broken or circumvented the authentication or authorisation system(s) and gained access to the system's storage. In such a situation, the unencrypted resources are completely vulnerable to the breaching attacker and any restrictions defined by the Access Control system are rendered worthless.\\
\vskip 0.5em
Due to these risks, a system must offer a last line of defence for such situations; a method of protecting the stored resources even when a breach has occurred. In the case of password storage, \citet{Teat2011} show that the risk of breaches is mitigated with cryptographic hashing, however since hashing is a one-way operation we cannot use it for resource storage.\\
Instead we must integrate a form of at-rest encryption to securely store resources as unintelligible binary blobs that cannot be interpreted by man or machine. Such encryption relies on the employment of a block cipher algorithm and the current NIST guidance offers two approved block cipher algorithms \citep{NIST2017}; \acrfull{aes} and Triple DES as described by \citet{Daemen2003} \& \citet{Barker2017}.\\
Unfortunately, both block cipher algorithms are forms of \textit{symmetric}-key encryption which require the same key for encryption and decryption. This usually requires the service provider to store the key(s) separately from the resources and ultimately leaves a single party in control of both keys and encrypted resources, as with Google Drive \& OneDrive business accounts \citep{Winder2018}.

\subsection{Choosing ABE}
\label{subsec:analysis_abe}

\acrfull{abe} by comparison offers the possibility of storing encrypted resources with block cipher algorithms such as \acrshort{aes} 128-bit, yet without the requirement of storing keys. A \textit{ciphertext policy} \acrshort{abe} system for example binds an \acrshort{aes} ciphertext with a policy that describes who shall be able to decrypt it \citep{Akinyele2011} and employs Public Key cryptography (as described in \cref{sec:bkgr_pub_key_infr}) to enforce the policy.\\
In this context, decryption keys are private user keys that have been generated and then signed by a Master Key Server. These keys are generated from a user's attributes, as defined by the organisation, such as (role$=$Staff $\alt$ accountStatus$=$Active $\alt$ department$=$\acrshort{dcs} $\alt$ jobField$=$Research \& Teaching) representing a current member of staff in the Department of Computing Science's Research \& Teaching field.
\vskip 0.5em
Additionally, as an \acrshort{abe} system relies on Public Key cryptography, anyone may encrypt a resource with a policy using the distributed master public key, however only private user keys are capable of decrypting resources. These keys must be generated and then signed by a designated \acrfull{mks} (or private key generator) that remains the only entity with access to the master \textit{private} key. When a user key is created they can be created with a random seed, ensuring that two users with different levels of access cannot collude to form a new key with more access than they have individually \citep{Akinyele2011}, providing implicit \textit{collusion resistance}.\\
Further, Access Control for a service is online only, meaning that if the service is taken offline there is no way for users to access theirs (or other's) resources. By comparison an \acrshort{abe} system requires that access can only be gained through decryption and that files must be decrypted locally \citep{Waters2011}. This means that in the event of the system being inaccessible, users can safely distribute encrypted resources by other means \textemdash\ such as physical transfers \textemdash\ without risking an information breach.

\subsection{ABE Implementation}
\label{subsec:analysis_abe_impl}

To work securely \& efficiently, an \acrshort{abe} system must implement Public Key cryptography as a layer \textit{on top of} a block cipher algorithm such as \acrshort{aes}. Although Public Key cryptography \textemdash\ for example the RSA algorithm \citep{Barker2016} \textemdash\ can encrypt whole resources without \acrshort{aes}, the process is much less efficient and consumes a greater quantity of compute resources in the process \citep{AlHasib2008}. As such, an \acrshort{abe} system should first use \acrshort{aes} to encrypt a resource's contents, producing an \acrshort{aes} \textit{symmetric} key and an encrypted binary blob of the resource.
\vskip 0.5em
Once the key and binary blob have been generated, an \acrshort{abe} system should then use Public Key cryptography to encrypt the key with a Boolean formula policy. An example policy, for the Department of Computing Science and a resource that can only be decrypted by staff members in the Research \& Teaching field, might look like (role(\textbf{s}) $\equiv$ Staff $\wedge{}$ jobField(\textbf{s}) $\equiv$ Research \& Teaching), where \textbf{s} represents the Subject or user attempting to decrypt the related resource.\\
The generated policy should then be embedded directly into the resulting encrypted resource and mathematically bound to the \acrshort{aes} ciphertext with Public Key cryptography, such that it is an absolute requirement that the formula resolve correctly for a provided decryption key \citep{Sahai2005}.
\vskip 0.5em
For the decryption process, the user's attributes are to be extracted from their key and imported into the resource's policy by an \acrshort{abe} system. The system would then attempt to resolve the policy and if and only if the policy resolves to true, the \acrshort{aes} key will be decrypted by the user key. Once the \acrshort{aes} key has been decrypted, the system proceeds to execute \acrshort{aes} decryption on the encrypted binary blob \citep{Akinyele2011}, finally returning an unencrypted resource that can be interpreted by man and machine.
